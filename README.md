# In_silico_evolution_Gene_and_Protein_Networks
Evolutionary Algorithms in C++ and Matlab for the in-silico-evolution of gene- and protein networks with specified pattern-forming functions in one spatial dimension. 


# README Gene_Networks_C++

Gene_Network_Evolution has been created by Florian Gartner in 2017 and provides C++ code to simulate the evolution of gene-expression networks whose gene products can react and diffuse in one spatial dimension.
This readme file refers to the basis version of the algorithm Gene_Network_Evolution. The extended version works similarly in its core however provides lots of additional features and functionalities (see below). The basis version relies on the C++ boost library which can be downloaded online (https://www.boost.org/) and must be added to the header search path.

In biology, a dynamics of interacting genes and diffusing proteins is supposed to be underlying to morphogenetic development like for example in Drosophila Melanogaster. This was also one of the major goals of the project for which the algorithm has originally been designed, to study pathways of evolution and properties of the gap-gene network in Drosophila Melanogaster. 

A gene-network in the algorithm is represented as a collection of genes together with a number of rules that describe how the gene-products (proteins) interact with themselves and with the genes thereby regulating the expression levels of the genes. In this way, the gene networks can invoke interesting spatio-temporal dynamics and patterns. By using appropriate fitness- or loss functions, the algorithm selects networks with the desired properties and functions. Here we only provide the simplest examples of fitness functions that select for a pattern of two opposing spatial gradients as well as a pattern of two Gaussian peaks (of the same or different protein species) one on left and one on the right hand side of the system (reminiscent of the pattern formed by the products of two gap-genes in D. Melanogaster). The structure of the algorithm allows to adapt the fitness evaluation functions and thus the features that are selected for with minimal effort. 

The algorithm starts with a number N of random initial networks. These networks are simulated and have their fitness evaluated. In the current implementation, the fitter 50% of the population are then reproduced and mutated. Afterwards the networks are simulated and evaluated again, which is repeated for several hundreds or thousands of iterations (generations). After several iterations, we typically obtain networks that perform the functions they were selected for very well and are typically also robust against mutations to some degree and against noise. 

The PNG in this repository shows the different types of reactions that can be added (or deleted) through a mutation. For example a mutation can add a new gene to the system, which expresses a new kind of protein at a rate that is chosen randomly initially. The column on the right shows how these reactions are represented mathematically in the system of differential equations. Furthermore, a mutation can introduce a new interaction between a protein species and a certain gene (forming a gene-protein-complex), upon which the expression rate of the gene attains a different value. This can also be iterated, i.e. a second protein species might bind after another species has already attached to the gene, whereupon the expression rate might change another time. A mutation can also introduce an interaction between two protein species, causing them to dimerize at a certain rate into a protein complex. Protein complexes can acquire the ability to bind to a gene and change its expression rate just like individual proteins do. Higher-order complexes consisting of several proteins can form as well. The inverse decay reactions of complexes might cause one of the binding partners to be degraded. Finally, there are conformational changes, which provoke a protein to change its state, for example, due to phosphorylation. The new protein state can subsequently acquire individual properties through further mutations. Hence, through the repeated action of mutations and selection, complex reaction networks built from these elementary reactions emerge that exhibit a specialized functionality.  

The class 'Genome' contains all the information necessary to specify a network. In particular, it contains special data containers called 'GeneticInstance' that store all relevant information about Proteins and Genes, Gene-Protein Complexes (GPComp), Protein-Complexes (PPComp), Phosphorylates (Phosph) and Protein Reactions (PPReact). The 'Genome' class also contains all necessary methods to mutate these instances and several methods that establish the interface with the differential equations solver that we use from the C++ boost library (essentially these methods serve to translate a network into a compact representation that the solver can handle fast and efficiently). The functions that provide the reaction-diffusion-dynamics for the differential equations solver are described in 'Dynamics_and_Fitness.h'. Furthermore, this file contains several classes that perform the fitness evaluation, selecting e.g. patterns consisting of two complementary gradients (FitnessEvaluation_ComplementaryGradients), two Gaussian peaks (FitnessEvaluation_2GaussianPeaks) or that can be adapted to match an arbitrary concentration profile (FitnessEvaluation_MatchProfiles). Finally, the class 'EvoAlg' performs the evolutionary procedure. To this end it requires a FitnessEvaluator to be specified, as well as an 'Evolver Type'. The Evolver thereby specifies the selection scheme. Here we implemented the simplest Evolver Type (Evolve_FitterHalf_Selection) that selects those 50% of the individuals with the highest fitness value in each generation. EvoAlg furthermore contains methods that allow to write the information of a network into a text file as well as to read such a text file and translate it back into a network in the usual representation. Parameters like the population size can be specified in EvoAlg.h.  

In its current setting, the algorithm selects for a stationary pattern composed of two complementary gradients (like bicoid and nanos in D.Melanogaster) with a population size N=20. A fitness of 100 corresponds to the case where the target pattern is matched exactly. Per default, the algorithm terminates as soon as a fitness of 95 is reached in one network or as soon as the maximum number of generations (=10000) is surpassed. Mutation schemes and fitness functions can be modified accordingly to select for any other desired features or functions of the reaction networks.

All this information referred to the basis version of the algorithm Gene_Network_Evolution. The extended version works similarly in its core however provides lots of additional features and functionality to analyze the evolved networks and the evolutionary pathways, additional types of mutations and selection schemes as well as additional fitness functions. Furthermore, it represents the data in a slightly different way and uses another (implicit) differential equations solver that has been adapted from the book 'Numerical Recipes in C++' and which is more efficient (see 'Implicit_Stepper_Sparse.h', 'Implicit_Stepper_Sparse.cpp' and 'Ode_Integrator.h' which have been adapted from Numerical Recipes). Furthermore, the extended version also provides the possibility to use simulated annealing to find the optimal parameter values in a network instead of the evolutionary algorithm. The simulated annealing algorithm is contained in LamSimAnn.h which has been provided by Patrick Hillenbrand, a former colleague of mine.
The extended version of the algorithm relies on three libraries: boost, eigen and Levenberg_Marquardt_Algorithm_levmar all of which can be downloaded online (https://www.boost.org/, https://eigen.tuxfamily.org/, https://hackage.haskell.org/package/levmar). The basis version only requires the boost library, which must be downloaded and added to the header search path.



# README Reaction_Networks_Matlab

Reaction_Network_Evolution has been created by Florian Gartner in 2019 and provides Matlab code to simulate the evolution of chemical or biological reaction-diffusion networks with one spatial dimension. A reaction network is organized as a collection of 'Elements', which represent chemicals or proteins (in different biochemical configurations, which can be either solved in the cytosol or bound to the membrane) as well as complexes of two or several proteins, and so-called reaction 'Arrows' which describe possible reactions between these Elements. This representation allows for a high degree of versatility for the code to be adapted to specific biochemical problems, which basically only requires to define the appropriate Arrows and corresponding Mutations. For example, one could easily extend the repertoire of possible reactions by effective reactions, like effective few-particle reactions or catalytic interactions of Michaelis-Menten type just by defining the classes of the corresponding Reaction Arrows and specifying how the Networks mutate (in Network.m) with respect to these reaction types. This might provides a possibility to speed up the evolution as it allows to find sophisticated solutions more easily than with only elementary reactions between the Elements. Furthermore, thanks to the organization of the Network in Subnetworks representing all different biochemical conformations of a protein species, it is possible to define special types of mutations in which large parts of the network are duplicated, which occurs, for example, as a result of gene duplication, recombination of chromosomes or horizontal gene transfer. This folder contains the basic version of the algorithm representing only elementary reactions (conformational switches, 2-particle reactions and the reverse decay reactions) and elementary mutations. 

The spatio-temporal reaction dynamics can be integrated either with Matlab's ode15s or Matlab's pdepe. For both cases we provide mex-functions (functions written in C++ and compiled for use in Matlab) for the time criticial function evaluations (reaction_diffusion_dynamics.mexmaci64 (source code: reaction_diffusion_dynamics.cpp)) and reaction_diffusion_dynamics_pdepe.mexmaci64 (source code: reaction_diffusion_dynamics_pdepe.cpp)). The fitness function provided in this example selects for networks that are capable of organizing themselves into and maintaining a left-right polarized state (i.e. a state in which certain species are more abundant on one side or the other) starting from an initial homogeneous distribution with some spatial noise. Polarization is an important feature in several bacteria and eukaryotic cells, which precedes cell division, cell motion or development. In order to select networks for other features just modify the Fitness function in 'Network.m' accordingly. 

To start the execution of the algorithm run 'Evolution.m'. Make sure that 'Utility' and 'Pdepe' with all subfolders are added to the Matlab path. The code is automatically executed in parallel if Matlab's parallelization toolbox (containing 'parfor') is available.

The population size N (default: N=20) and maximum number of simulated generations (default: 1000) can be changed in 'Evolution.m'. In its current implementation, 50% of the individuals with the highest fitness values are duplicated (reproduced) and mutated in each generation. The probabilities for the various mutations (change of rate constants, addition of elements or reactions or deletion of elements or reactions) can be modified in the function 'Mutate' and related functions in 'Network.m'.

'Element.m' defines the properties and methods of a single element (protein or chemical species). 'Subnetwork.m' defines the properties and methods of a subnetwork of elements, which consists of a 'basis element' (either a protein or protein complex) and a number of 'derived elements' representing different biochemical configurations of the basis element. The struct 'transitions' handles the reactions between the elements of the subnetwork. Finally, a 'Network' is essentially a collection of subnetworks as well as two structs 'reactions' and 'decays' that specify reactions between elements of different subnetworks, specifically dimerization reactions, which create a new basis element in a new subnetwork and decay reactions as the respective reverse reactions. Furthermore, 'Network.m' contains all the methods used to mutate the networks and evaluate a network's fitness (with respect to how well it can generate and maintain a polarized state in this example; the method 'FitnessPolarisation' is based on ode15s while 'FitnessPolarisation_pdepe' is based on pdepe whereby apart from the solver type both functions evaluate fitness in the same way). Moreover, it contains data types and methods that enable the interface to the differential equations solvers.
Finally, 'Evolution.m' executes the evolutionary process. All the mex functions and remaining Matlab functions (like 'Jacobian') are required for the differential equations solvers.
 
The current implementation and default settings simulate the evolution of basic reaction schemes that are selected for their ability to form and maintain polarized states in a one-dimensional spatial geometry. Thereby we assume that proteins ('Elements') can be either solved in the cytosol or bound to the membrane, which distinguishes their diffusion constants by two orders of magnitude (see parameter settings in 'FitnessPolarisation' and 'FitnessPolarisation_pdepe'). Mutation schemes and fitness functions can be modified accordingly to select for any other desired features or functions of the reaction networks.
