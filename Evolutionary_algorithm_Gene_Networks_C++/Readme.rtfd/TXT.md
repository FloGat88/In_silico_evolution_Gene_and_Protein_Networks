
Gene_Network_Evolution has been created by Florian Gartner in 2017 and provides C++ code to simulate the evolution of gene-expression networks whose gene products can react and diffuse in one spatial dimension.\
This readme file refers to the basis version of the algorithm Gene_Network_Evolution. The extended version works similarly in its core however provides lots of additional features and functionalities (see below). The basis version relies on the C++ boost library which can be downloaded online (https://www.boost.org/) and must be added to the header search path.\
\
In biology, a dynamics of interacting genes and diffusing proteins is supposed to be underlying to morphogenetic development like for example in Drosophila Melanogaster. This was also one of the major goals of the project for which the algorithm has originally been designed, to study pathways of evolution and properties of the gap-gene network in Drosophila Melanogaster. \
\
A gene-network in the algorithm is represented as a collection of genes together with a number of rules that describe how the gene-products (proteins) interact with themselves and with the genes thereby regulating the expression levels of the genes. In this way, the gene networks can invoke interesting spatio-temporal dynamics and patterns. By using appropriate fitness- or loss functions, the algorithm selects networks with the desired properties and functions. Here we only provide the simplest examples of fitness functions that select for a pattern of two opposing spatial gradients as well as a pattern of two Gaussian peaks (of the same or different protein species) one on left and one on the right hand side of the system (reminiscent of the pattern formed by the products of two gap-genes in D. Melanogaster). The structure of the algorithm allows to adapt the fitness evaluation functions and thus the features that are selected for with minimal effort. \
\
The algorithm starts with a number N of random initial networks. These networks are simulated and have their fitness evaluated. In the current implementation, the fitter 50% of the population are then reproduced and mutated. Afterwards the networks are simulated and evaluated again, which is repeated for several hundreds or thousands of iterations (generations). After several iterations, we typically obtain networks that perform the functions they were selected for very well and are typically also robust against mutations to some degree and against noise. \
\
Below is table that shows the different types of reactions that can be added (or deleted) through a mutation. For example a mutation can add a new gene to the system, which expresses a new kind of protein at a rate that is chosen randomly initially. The column on the right shows how these reactions are represented mathematically in the system of differential equations. Furthermore, a mutation can introduce a new interaction between a protein species and a certain gene (forming a gene-protein-complex), upon which the expression rate of the gene attains a different value. This can also be iterated, i.e. a second protein species might bind after another species has already attached to the gene, whereupon the expression rate might change another time. A mutation can also introduce an interaction between two protein species, causing them to dimerize at a certain rate into a protein complex. Protein complexes can acquire the ability to bind to a gene and change its expression rate just like individual proteins do. Higher-order complexes consisting of several proteins can form as well. The inverse decay reactions of complexes might cause one of the binding partners to be degraded. Finally, there are conformational changes, which provoke a protein to change its state, for example, due to phosphorylation. The new protein state can subsequently acquire individual properties through further mutations. Hence, through the repeated action of mutations and selection, complex reaction networks built from these elementary reactions emerge that exhibit a specialized functionality.  \
\
The class 'Genome' contains all the information necessary to specify a network. In particular, it contains special data containers called 'GeneticInstance' that store all relevant information about Proteins and Genes, Gene-Protein Complexes (GPComp), Protein-Complexes (PPComp), Phosphorylates (Phosph) and Protein Reactions (PPReact). The 'Genome' class also contains all necessary methods to mutate these instances and several methods that establish the interface with the differential equations solver that we use from the C++ boost library (essentially these methods serve to translate a network into a compact representation that the solver can handle fast and efficiently). The functions that provide the reaction-diffusion-dynamics for the differential equations solver are described in 'Dynamics_and_Fitness.h'. Furthermore, this file contains several classes that perform the fitness evaluation, selecting e.g. patterns consisting of two complementary gradients (FitnessEvaluation_ComplementaryGradients), two Gaussian peaks (FitnessEvaluation_2GaussianPeaks) or that can be adapted to match an arbitrary concentration profile (FitnessEvaluation_MatchProfiles). Finally, the class 'EvoAlg' performs the evolutionary procedure. To this end it requires a FitnessEvaluator to be specified, as well as an 'Evolver Type'. The Evolver thereby specifies the selection scheme. Here we implemented the simplest Evolver Type (Evolve_FitterHalf_Selection) that selects those 50% of the individuals with the highest fitness value in each generation. EvoAlg furthermore contains methods that allow to write the information of a network into a text file as well as to read such a text file and translate it back into a network in the usual representation. Parameters like the population size can be specified in EvoAlg.h.  \
\
In its current setting, the algorithm selects for a stationary pattern composed of two complementary gradients (like bicoid and nanos in D.Melanogaster) with a population size N=20. A fitness of 100 corresponds to the case where the target pattern is matched exactly. Per default, the algorithm terminates as soon as a fitness of 95 is reached in one network or as soon as the maximum number of generations (=10000) is surpassed. Mutation schemes and fitness functions can be modified accordingly to select for any other desired features or functions of the reaction networks.\
\
All this information referred to the basis version of the algorithm Gene_Network_Evolution. The extended version works similarly in its core however provides lots of additional features and functionality to analyze the evolved networks and the evolutionary pathways, additional types of mutations and selection schemes as well as additional fitness functions. Furthermore, it represents the data in a slightly different way and uses another (implicit) differential equations solver that has been adapted from the book 'Numerical Recipes in C++' and which is more efficient (see 'Implicit_Stepper_Sparse.h', 'Implicit_Stepper_Sparse.cpp' and 'Ode_Integrator.h' which have been adapted from Numerical Recipes). Furthermore, the extended version also provides the possibility to use simulated annealing to find the optimal parameter values in a network instead of the evolutionary algorithm. The simulated annealing algorithm is contained in LamSimAnn.h which has been provided by Patrick Hillenbrand, a former colleague of mine.\
The extended version of the algorithm relies on three libraries: boost, eigen and Levenberg_Marquardt_Algorithm_levmar all of which can be downloaded online (https://www.boost.org/, https://eigen.tuxfamily.org/, https://hackage.haskell.org/package/levmar). The basis version only requires the boost library, which must be downloaded and added to the header search path.\
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0
\cf0 {{\NeXTGraphic types_of_reactions.png \width12720 \height11580 \appleattachmentpadding0 \appleembedtype0 \appleaqc
}Â¬}\
Types of reactions to built up the networks and their mathematical representations in the Ode System.\
\
 \
}
